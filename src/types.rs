use crate::config;

// Common point type used throughout the game
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct Point {
    pub x: f64,
    pub y: f64,
}

impl Point {
    /// Calculate the Euclidean distance between two points
    pub fn distance(&self, other: &Point) -> f64 {
        let dx = self.x - other.x;
        let dy = self.y - other.y;
        (dx * dx + dy * dy).sqrt()
    }
}

// Scanner component properties
#[derive(Debug, Clone, Copy)]
pub struct Scanner {
    #[allow(dead_code)]
    pub fov: f64, // Field of view in degrees
    #[allow(dead_code)]
    pub range: f64, // Maximum scan range in coordinate units
    #[allow(dead_code)]
    pub last_scan_distance: f64, // Last detected target distance (0.0 if none)
    #[allow(dead_code)]
    pub last_scan_angle: f64, // Last detected target absolute angle
}

impl Default for Scanner {
    fn default() -> Self {
        Scanner {
            fov: config::DEFAULT_SCANNER_FOV,
            range: config::DEFAULT_SCANNER_RANGE,
            last_scan_distance: 0.0,
            last_scan_angle: 0.0,
        }
    }
}

// Ranged weapon properties
#[derive(Debug, Clone, Copy)]
pub struct RangedWeapon {
    pub base_damage: f64,      // Base damage before scaling
    pub projectile_speed: f64, // Base projectile speed in units/cycle
}

impl Default for RangedWeapon {
    fn default() -> Self {
        RangedWeapon {
            base_damage: config::DEFAULT_RANGED_DAMAGE,
            projectile_speed: config::DEFAULT_PROJECTILE_SPEED,
        }
    }
}

// Projectile state (for tracking fired projectiles)
#[derive(Debug, Clone, Copy)]
pub struct Projectile {
    pub position: Point,
    pub prev_position: Point,
    pub direction: f64,    // Absolute angle in degrees
    pub speed: f64,        // Current speed in units/cycle
    pub power: f64,        // Power level used to fire (affects damage)
    pub base_damage: f64,  // Base damage of the projectile
    pub source_robot: u32, // ID of robot that fired this projectile
}

/// Commands generated by robots to be executed by the Arena
#[derive(Debug, Clone)] // Clone needed for queue processing
pub enum ArenaCommand {
    SpawnProjectile(Projectile),
    SpawnMuzzleFlash { position: Point, direction: f64 },
}
